#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jun  2 02:33:58 2020

@author: prabhanshu
"""
from datetime import date, time, timedelta
from dataclasses import dataclass, field
from typing import List, Set, Tuple, Dict
#from math import pi
import re, textwrap, shelve
from itertools import count, groupby, repeat, islice
from collections import namedtuple
from Journal.tasks_new import *
from pprint import pprint
# estd_time, actual_time, notes, eff_satisfaction
@dataclass #change the repr later
class DayOfTask():
    day: int = 1
    estd_time: timedelta = None
    actual_time: timedelta = timedelta(0)
    notes: str = None
    eff_satisfaction: int = None
    completed: bool = False
    
class Task():
    """Class to act as a database. It can read and create a task object from a DB.
    It can also write those changes.
    """
    days = []
    
    def __init__(self, task_string, day=DayOfTask()):
        self.task_string = task_string
        self.day = day
        if self.day.day == 1 :
            self.days = [self.day]
        elif len(self.days) == self.days[-1].day :
            current_day = len(self.days)
            self.days.append(DayOfTask(current_day+1))
       
    def new_day(self):
        if len(self.days) == self.days[-1].day :
            current_day = len(self.days)
            self.days.append(DayOfTask(current_day+1))
    def __repr__(self):
        return f"""task: {self.task_string}
day: {self.days}
"""        
    @classmethod
    def from_task_string(cls, task_string):
        print(task_string)
        estd_time = input("How much time do you think this would take ?\n")
        notes = input("Do you want to add any notes? \n")
        cls.day = DayOfTask(day=1, estd_time=estd_time, notes=notes)
        return cls(task_string, cls.day)
    
#    @classmethod
#    def from_db(cls, 
#                date: datetime.date = date.today(), 
#                #all_entries_after_date: bool = False,
#                ):
#        "returns a list of tasks on that day"
#        pattern = re.compile(r"""
#                             
#                             """,re.VERBOSE)
#        with open('test', 'r') as f:
#        data = f.readlines()
#        for line_no_in_reverse, line in data[::-1]:
#            
#    
    @staticmethod
    def wrap(text, width=80,subsequent_indent=4): 
        return textwrap.fill(text=text, width=width,
                         initial_indent="\u2022 ", #bullet
                         subsequent_indent=(subsequent_indent*'\t'+'  '))

            
    def forDB(self):
        if (len(self.days)==1 and 
            self.days[0].day == 1 and 
            self.days[0].actual_time == timedelta(0)):
            return f'''
  [Part]   {t.task_string}
  Day: 1   Estimated Time: {t.days[0].estd_time}        Actual Time: [--only-initialization-done--]
            Notes for future/ reasons for not finishing:
               {Task.wrap(t.days[0].notes, width=50)}   
        '''
@dataclass            
class Day(object):
    date: date
    tasks: List['Task'] = field(default_factory=list)

    def toDB(self):
        with shelve.open('database') as database:
            database[self.date.isoformat()] = self

    @classmethod
    def fromDB(cls, date):
        with shelve.open('database') as database:
            day = database[date.isoformat()]
            
        return cls(day.date, day.tasks)

    
    
    
    
    
    
    
    
#class Seeker(object):
#    def __init__(self, lines: List[str]):
#        self.lines = lines
#    def __repr__(self):
#        return str(self.lines)
#    
#    @classmethod
#    def from_date(cls, lines, date):
#        sought = list(islice(lines, *Seeker.date2line_num(lines, date)))
#        return cls(sought)
#    
##    @classmethod
##    def on_task(cls, lines, Sno = 1):
##        
#    @staticmethod
#    def date2line_num(task_db: List[str], date=date.today(), subsequent=False):
#        """
#        Returns a pair of line numbers which correspond to a dated entry in a text file, or
#        If subsequent is True, a list of line numbers of all the subsequent dates is returned.
#        
#        line numbers start from 0
#        task_db is the list of lines of a text file which can be read using:
#            with open('sample database','r') as f: 
#                task_db = f.readlines()
#        """
#        pattern = re.compile(r'Date: (\d{2})/(\d{2})/(\d{4}) \w+ \w+')
#        #tip-- read following 5 lines from bottom.
#        date_line = ((date.fromisoformat('-'.join(reversed(  #reversed because we write dd/mm/yy but python requires yy/mm/dd
#                re.match(pattern, line).groups()))), index)
#            for index, line in zip(count(),lines) if re.match(pattern,line))
#        
#        line_numbers = []
#        for date_on_db, corr_line in date_line:
#            if date_on_db >= date: line_numbers.append(corr_line)
#            if subsequent == False:
#                if len(line_numbers) == 2: break
#                
#        return line_numbers
#    
#    



        

    

def locater():
    f.write('.<<HERE<<')


x = 'Comlete problem 7 on Hacker rank'
t = Task(x)
t.days[0].notes=7*x
                 







#@dataclass
#class Calc2:
#    
#    kWhr: float
#    avg_kW: float = 2.5
#    
#    peak_kW = 5
#    density = 7500
#    H: ClassVar[float] = 5
#    HtoD: ClassVar[float] = 1
#    
#    def __post_init__(self):
#        self.e = self.kWhr*3600
#        self.W = self.e/self.H 
#        self.m = self.W/9.8066
#        self.Dia = (4 * self.e /(
#                self.HtoD * self.H * self.density * 9.8066 * pi))**(1/3)
#        self.h = self.Dia * self.HtoD
#        self.rate = self.peak_kW * 1000000 /(
#                self.density * 3.1415 * (self.Dia**2) * self.h/4*9.8066)
#        self.avg_rate = self.avg_kW*1000000/(
#                self.density * 3.1415 * (self.Dia**2) * self.h/4*9.8066)
#    def show(self):
#        print( 
#            f"""Units of Electricity (kWhr) = {self.kWhr}
#Mass of the dead weight = {self.m:.1f}kg and Weight = {self.W:.0f} Newton
#Diameter = {self.Dia*100:.2f}cm     ;   Height = {self.h*100:.2f}cm
#Peak descend rate = {self.rate:.3f}mm/s
#Average descend = {self.avg_rate:.3f}mm/s""")
